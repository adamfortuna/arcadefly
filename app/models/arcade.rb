class Arcade < ActiveRecord::Base
  extend ActiveSupport::Memoizable
  include Addressable
  acts_as_taggable

	PUBLIC_FIELDS = [:id, :created_at, :updated_at, :permalink, :name, :phone, :website, :notes, :playables_count, :frequentships_count]
	PUBLIC_FIELDS_WITH_ADDRESS = [PUBLIC_FIELDS, :street, :city, :postal_code, :lat, :lng, :name].flatten

	has_permalink :name
  
  belongs_to :profile
	has_many :playables, :dependent => :destroy
	has_many :games, :through => :playables

	has_many :frequentships, :dependent => :destroy
	has_many :profiles, :through => :frequentships

	has_many :hours, :as => :timeable, :order => 'day, start, end', :dependent => :destroy#, :accessible => true,
	
	has_many :editors, :through => :claims, :source => :profile, :conditions => ['claims.approved=?', true]
	has_many :claims, :dependent => :destroy

	# Validations
	validates_presence_of :address
	validates_associated :address
	validates_presence_of :name, :message => "is required."
	validates_uniqueness_of :permalink
	validates_format_of :website, :with => /^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?$/ix, 
	                    :if => :website?
	                    
  validates_format_of :owner_email, :with => /^([^@\s]{1}+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i, :if => :owner_email?
  
  attr_accessible :name, :phone, :notes, :all_tags, :address, :website, :owner_name, :owner_email #, :all_hours, :profile

	def to_param
    permalink
  end

  def self.per_page
    25
  end

  def title
    name
  end

  def has_profiles?
    frequentships.size > 0
  end
  
  def has_games?
    playables.size > 0
  end

  def has_game?(game)
    playables.find_by_game_id(game.id).length > 0
  end
  memoize :has_game?

  def frequentships_rank
    Arcade.count(:conditions => ['frequentships_count > ?', frequentships_count]) + 1
  end
  memoize :frequentships_rank
  
  def playables_rank
    Arcade.count(:conditions => ['playables_count > ?', playables_count]) + 1
  end
  memoize :playables_rank
  
  def all_tags=(current_tags)
    if(current_tags.is_a?(Array))
      self.tag_list = current_tags.join(',')
    else
      self.tag_list = current_tags
    end
  end

  def self.paged_find_tagged_with(tags, args = {})
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql
      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)
      paginate(options.merge(:count => { :select => options[:select].gsub('*', 'id') }))
    end
  end
  
  def self.recent
    self.find(:all, :order => 'created_at desc', :include => [ { :address => [:country, :region] }], :limit => 10)
  end
  
  def has_hours?
    false
  end

  protected
  after_create :create_claim
	def create_claim
	  claims << Claim.create(:profile => self.profile, :level => 0, :approved => true, :name => self.profile.display_name, :reason => "Added arcade to ArcadeFly") if self.profile
  end
	
end